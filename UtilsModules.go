/*******************************************************************************
 * Copyright 2023-2023 Edw590
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 ******************************************************************************/

package Utils

import (
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"Utils/Tcef"
)

const (
	// _BIN_REL_DIR is the relative path to the binaries' directory from PersonalConsts._VISOR_DIR.
	_BIN_REL_DIR string = "bin"
	// _DATA_REL_DIR is the relative path to the data directory from PersonalConsts._VISOR_DIR.
	_DATA_REL_DIR string = "data"
	// _TEMP_FOLDER is the relative path to the temporary folder from PersonalConsts._VISOR_DIR.
	_TEMP_FOLDER string = _DATA_REL_DIR + "Temp"
	// _USER_DATA_REL_DIR is the relative path to the user data directory from PersonalConsts._VISOR_DIR.
	_USER_DATA_REL_DIR string = _DATA_REL_DIR + "UserData"
	// _PROGRAM_DATA_REL_DIR is the relative path to the program data directory from PersonalConsts._VISOR_DIR.
	_PROGRAM_DATA_REL_DIR string = _DATA_REL_DIR + "ProgramData"
	// _WEBSCRAPE_WEBSITE_FILES_REL_DIR is the relative path to the website files directory from PersonalConsts._VISOR_DIR.
	_WEBSITE_FILES_REL_DIR string = _DATA_REL_DIR + "Website/files_EOG"
)

// _MOD_FOLDER_PREFFIX is the preffix of the modules' folders.
const _MOD_FOLDER_PREFFIX string = "MOD_"

// _MOD_GEN_ERROR_CODE is the exit code of a module when a general error occurs.
const _MOD_GEN_ERROR_CODE int = 3234

const (
	// _MOD_GEN_INFO_JSON is the name of the file containing the module-generated information
	_MOD_GEN_INFO_JSON string = "mod_gen_info.json"
	// _MOD_GEN_INFO_JSON_TMP is the name of the temporary file containing the module-generated information
	_MOD_GEN_INFO_JSON_TMP string = "mod_gen_info.json_tmp"
	// _MOD_USER_INFO_JSON is the name of the file containing the user-given module information (read-only by the
	// module)
	_MOD_USER_INFO_JSON string = "mod_user_info.json"
)

// MOD_NUMS_NAMES is a map of the numbers of the modules and their names. Use with the NUM_MOD_ constants.
var MOD_NUMS_NAMES map[int]string = map[int]string{
	1: "Modules Manager",
	2: "S.M.A.R.T. Checker",
	4: "RSS Feed Notifier",
	5: "Email Sender",
	6: "Online Information Checker",
}

const (
	NUM_MOD_ModManager      int = 1
	NUM_MOD_SMARTChecker    int = 2
	NUM_MOD_RssFeedNotifier int = 4
	NUM_MOD_EmailSender     int = 5
	NUM_MOD_OnlineInfoChk   int = 6

	NUM_MODULES             int = 5
)

// MAX_WAIT_NEXT_TIMESTAMP_S is the maximum number of seconds to wait for the next timestamp to be registered by a module.
const MAX_WAIT_NEXT_TIMESTAMP_S int64 = 5

// _ModRunInfo is the struct of the file containing information about the running of a module.
type _ModRunInfo struct {
	// Last_pid is the PID of the last process that ran the module.
	Last_pid int
	// Last_timestamp_ns is the last timestamp in nanoseconds registered by the module.
	Last_timestamp_ns int64
}

type _ModDirsInfo struct {
	// ProgramData is the path to the directory of the program data files.
	ProgramData GPath
	// UserData is the path to the directory of the private user data files.
	UserData GPath
	// Temp is the path to the directory of the private temporary files of the module.
	Temp GPath
}

type _ModGenInfo[T any] struct {
	// Mod_num is the number of the module.
	Mod_num int
	// ModRunInfo is the information about the running of the module.
	ModRunInfo _ModRunInfo
	// ModSpecInfo is the information specific to the module, provided by the module itself. It should be a struct (can
	// be private) and ALL its fields should be exported.
	ModSpecInfo T
}

type ModuleInfo[T any] struct {
	// Name is the name of the module.
	Name string
	// ModGenInfo is the information generated by the module.
	ModGenInfo _ModGenInfo[T]
	// ModDirsInfo is the information about the directories of the module.
	ModDirsInfo _ModDirsInfo
}

/*
RealMain is the type of the realMain() function of a module.

realMain is the function that does the actual work of a module (it's equivalent to what main() would normally be).

The generic parameter names are to avoid name conflicts.

-----------------------------------------------------------

– Params:
  - realMain_param_1 – the ModuleInfo struct of the module with the ModuleInfo.ModGenInfo.ModSpecInfo field of the
    requested type by the module
*/
type RealMain func(realMain_param_1 any)

/*
ModStartup does the startup routine for a module and executes its realMain() function, catching any fatal errors and
sending an email with them.

Call this as the ONLY thing in the main() function of a module.

-----------------------------------------------------------

– Generic params:
  - T – the type of the ModuleInfo.ModGenInfo.ModSpecInfo field of the requested type by the module

– Params:
  - mod_num – the number of the module
  - realMain – a pointer to the realMain() function of the module
*/
func ModStartup[T any](mod_num int, realMain RealMain) {
	// Try to run the module, catching any fatal errors and sending an email with them.
	var mod_name string = "ERROR"
	var errs bool = false
	Tcef.Tcef{
		Try: func() {
			// Module startup routine //

			mod_name = GetModNameMODULES(mod_num)
			printStartupSequenceMODULES(mod_name)

			// Initialize the personal "constants"
			err := PersonalConsts_GL.Init()
			if err != nil {
				fmt.Println("CRITICAL ERROR: " + GetFullErrorMsgGENERAL(err))
				errs = true

				return
			}

			if IsModRunningMODULES(mod_num) {
				fmt.Println("Module already running. Exiting...")
				return
			}

			var moduleInfo ModuleInfo[T] = ModuleInfo[T]{
				ModGenInfo:  _ModGenInfo[T]{
					Mod_num:    mod_num,
					ModRunInfo: _ModRunInfo{},
				},
				Name:        GetModNameMODULES(mod_num),
				ModDirsInfo: _ModDirsInfo{
					ProgramData: getProgramDataDirMODULES(mod_num),
					UserData:    getUserDataDirMODULES(mod_num),
					Temp:        getModTempDirMODULES(mod_num),
				},
			}

			moduleInfo.getGenInfo()

			moduleInfo.updateModRunInfo()

			// Execute realMain()
			realMain(moduleInfo)
		},
		Catch: func(e Tcef.Exception) {
			errs = true

			var str_error string = GetFullErrorMsgGENERAL(e)

			// Print the error and send an email with it
			fmt.Println(str_error)
			if err := SendModErrorEmailMODULES(mod_num, str_error); nil != err {
				fmt.Println("Error sending email with error:\n" + GetFullErrorMsgGENERAL(err) + "\n-----\n" + str_error)
			}
		},
	}.Do()

	// Module shutdown routine //

	if errs {
		printShutdownSequenceMODULES(errs, mod_name, strconv.Itoa(mod_num))

		os.Exit(_MOD_GEN_ERROR_CODE)
	}

	printShutdownSequenceMODULES(errs, mod_name, strconv.Itoa(mod_num))
}

/*
GetModNameMODULES gets the name of a module.

-----------------------------------------------------------

– Params:
  - mod_num – the number of the module

– Returns:
  - the name of the module or an empty string if the module number is invalid
*/
func GetModNameMODULES(mod_num int) string {
	if mod_name, ok := MOD_NUMS_NAMES[mod_num]; ok {
		return mod_name
	}

	return "INVALID MODULE NUMBER"
}

/*
SendModErrorEmailMODULES directly sends an email to the developer with the error message.

This function does *not* use any modules to do anything. Only utility functions. So it can be used from any
module.

-----------------------------------------------------------

– Params:
  - mod_num – the number of the module from which the error occurred
  - error – the error message

– Returns:
  - nil if the email was sent successfully, otherwise an error
*/
func SendModErrorEmailMODULES(mod_num int, err_str string) error {
	var things_replace map[string]string = map[string]string{
		MODEL_INFO_MSG_BODY_EMAIL : err_str,
		MODEL_INFO_DATE_TIME_EMAIL: GetDateTimeStrTIMEDATE(-1),
	}
	var email_info = GetModelFileEMAIL(MODEL_FILE_INFO, things_replace)
	email_info.Subject = "Error in module: " + GetModNameMODULES(mod_num)

	message_eml, mail_to, success := prepareEmlEMAIL(email_info)
	if !success {
		return errors.New("error preparing email")
	}

	return SendEmailEMAIL(message_eml, mail_to, true)
}

/*
LoopSleep sleeps for the given number of seconds (with a caveat) and updates the ModGenInfo file.

If the number of seconds exceeds MAX_WAIT_NEXT_TIMESTAMP_S, the latter is used instead.

-----------------------------------------------------------

– Params:
  - s – the number of seconds to sleep

– Returns:
  - true if the module should stop, false otherwise
*/
func (moduleInfo *ModuleInfo[T]) LoopSleep(s int64) bool {

	var curr_s int64 = time.Now().Unix()
	var end_s int64 = curr_s + s
	for curr_s < end_s {
		if moduleInfo.signalledToStop() {
			return true
		}

		var seconds = s
		if s > MAX_WAIT_NEXT_TIMESTAMP_S {
			seconds = MAX_WAIT_NEXT_TIMESTAMP_S
		}
		time.Sleep(time.Duration(seconds) * time.Second)

		moduleInfo.updateModRunInfo()

		curr_s = time.Now().Unix()
	}

	return false
}

/*
GetModUserInfo gets the information about the module from the user info file.

-----------------------------------------------------------

– Params:
  - v – a pointer to the variable where the information will be stored, with the struct in which the file is written in

– Returns:
  - true if the file was read successfully, false otherwise
*/
func (moduleInfo *ModuleInfo[T]) GetModUserInfo(v any) bool {
	var p_json_file *string = moduleInfo.ModDirsInfo.UserData.Add2(false, _MOD_USER_INFO_JSON).ReadTextFile()
	if p_json_file == nil {
		return false
	}

	return FromJsonGENERAL([]byte(*p_json_file), v)
}

/*
signalledToStop checks if the module was signalled to stop.

-----------------------------------------------------------

– Returns:
  - true if the module was signalled to stop, false otherwise
*/
func (moduleInfo *ModuleInfo[T]) signalledToStop() bool {
	var stop_file_path GPath = moduleInfo.ModDirsInfo.UserData.Add2(false, "STOP")
	if stop_file_path.Exists() {
		_ = stop_file_path.Remove()

		return true
	}

	return false
}

/*
Update updates the information about the module in its generated information file.

-----------------------------------------------------------

– Params:
  - mod_num – the number of the module

– Returns:
  - nil if the update was successful, false otherwise
*/
func (modGenInfo *_ModGenInfo[T]) Update() error {
	var json_str string = *ToJsonGENERAL(&modGenInfo)

	var file_path_curr GPath = getUserDataDirMODULES(modGenInfo.Mod_num).Add2(false, _MOD_GEN_INFO_JSON)
	var file_path_new GPath = getUserDataDirMODULES(modGenInfo.Mod_num).Add2(false, _MOD_GEN_INFO_JSON_TMP)

	var err error = file_path_new.WriteTextFile(json_str)
	if nil != err {
		return err
	}

	return os.Rename(file_path_new.GPathToStringConversion(), file_path_curr.GPathToStringConversion())
}

/*
getGenInfo gets the information about the module from its generated information file.
 */
func (moduleInfo *ModuleInfo[T]) getGenInfo() {
	// Get information from the existing mod_gen_info.json file
	// Check first if the temporary file exists
	var p_info []byte = moduleInfo.ModDirsInfo.UserData.Add2(false, _MOD_GEN_INFO_JSON_TMP).ReadFile()
	if nil == p_info {
		// If not, check if the main file exists
		p_info = moduleInfo.ModDirsInfo.UserData.Add2(false, _MOD_GEN_INFO_JSON).ReadFile()
		if nil == p_info {
			// If not, empty struct (new file)

			goto new_file
		}
	}

	FromJsonGENERAL(p_info, &moduleInfo.ModGenInfo)

	new_file:
}

/*
printStartupSequenceMODULES prints the startup sequence of a module.

-----------------------------------------------------------

– Params:
  - mod_name – the name of the module
*/
func printStartupSequenceMODULES(mod_name string) {
	fmt.Println("//------------------------------------------\\\\")
	fmt.Println("--- " + mod_name + " ---")
	fmt.Println("V.I.S.O.R. Systems")
	fmt.Println("------------------")
	fmt.Println()
}

/*
printShutdownSequenceMODULES prints the shutdown sequence of a module.

-----------------------------------------------------------

– Params:
  - errors – true if the module is exiting with errors, false otherwise
  - mod_name – the name of the module
  - mod_num – the number of the module
*/
func printShutdownSequenceMODULES(errors bool, mod_name string, mod_num string) {
	fmt.Println()
	fmt.Println("---------")
	if errors {
		fmt.Println("Exiting with ERRORS the module \"" + mod_name + "\" (number " + mod_num + ")...")
	} else {
		fmt.Println("Exiting normally the module \"" + mod_name + "\" (number " + mod_num + ")...")
	}
	fmt.Println("\\\\------------------------------------------//")
}

/*
getProgramDataDirMODULES gets the full path to the program data directory of a module.

-----------------------------------------------------------

– Params:
  - mod_num – the number of the module

– Returns:
  - the full path to the program data directory of the module
*/
func getProgramDataDirMODULES(mod_num int) GPath {
	return PersonalConsts_GL._VISOR_DIR.Add2(true, _PROGRAM_DATA_REL_DIR, _MOD_FOLDER_PREFFIX + strconv.Itoa(mod_num))
}

/*
getUserDataDirMODULES gets the full path to the private user data directory of a module.

-----------------------------------------------------------

– Params:
  - mod_num – the number of the module

– Returns:
  - the full path to the private data directory of the module
*/
func getUserDataDirMODULES(mod_num int) GPath {
	return PersonalConsts_GL._VISOR_DIR.Add2(true, _USER_DATA_REL_DIR, _MOD_FOLDER_PREFFIX + strconv.Itoa(mod_num))
}

/*
getModTempDirMODULES gets the full path to the private temporary directory of a module.

-----------------------------------------------------------

– Params:
  - mod_num – the number of the module

– Returns:
  - the full path to the private temporary directory of the module
*/
func getModTempDirMODULES(mod_num int) GPath {
	return PersonalConsts_GL._VISOR_DIR.Add2(true, _TEMP_FOLDER, _MOD_FOLDER_PREFFIX + strconv.Itoa(mod_num))
}

/*
updateModRunInfo updates the information about the running of a module.

-----------------------------------------------------------

– Returns:
  - the path to the file containing the information about the running of the module
 */
func (moduleInfo *ModuleInfo[T]) updateModRunInfo() GPath {
	var mod_num int = moduleInfo.ModGenInfo.Mod_num

	files, _ := os.ReadDir(getUserDataDirMODULES(mod_num).GPathToStringConversion())

	// Remove all the old info files
	for _, file := range files {
		if strings.HasPrefix(file.Name(), "PID=") {
			err := moduleInfo.ModDirsInfo.UserData.Add2(false, file.Name()).Remove()
			if nil != err {
				panic(err)
			}
		}
	}

	var curr_pid int = os.Getpid()
	var curr_ts_ns int64 = time.Now().UnixNano()

	var new_info_file GPath = getUserDataDirMODULES(mod_num).Add2(false, "PID="+strconv.Itoa(curr_pid)+
				"_TS="+strconv.FormatInt(curr_ts_ns, 10))
	_ = new_info_file.Create(true)

	moduleInfo.ModGenInfo.ModRunInfo.Last_pid = curr_pid
	moduleInfo.ModGenInfo.ModRunInfo.Last_timestamp_ns = curr_ts_ns
	_ = moduleInfo.ModGenInfo.Update()

	return new_info_file
}

/*
IsModRunningMODULES checks if a module is already running.

-----------------------------------------------------------

– Params:
  - mod_num – the number of the module

– Returns:
  - true if the module is running, false otherwise
*/
func IsModRunningMODULES(mod_num int) bool {
	var curr_pid int = os.Getpid()

	files, err := os.ReadDir(getUserDataDirMODULES(mod_num).GPathToStringConversion())
	if nil != err {
		return false
	}

	for _, file := range files {
		if strings.HasPrefix(file.Name(), "PID=") {
			var file_path GPath = getUserDataDirMODULES(mod_num).Add2(false, file.Name())

			var info_list []string = strings.Split(file.Name(), "_")
			var pid_str string = strings.TrimPrefix(info_list[0], "PID=")
			var ts_str string = strings.TrimPrefix(info_list[1], "TS=")

			var pid int
			if pid, err = strconv.Atoi(pid_str); nil != err {
				_ = file_path.Remove()

				continue
			}
			var ts int64
			if ts, err = strconv.ParseInt(ts_str, 10, 64); nil != err {
				_ = file_path.Remove()

				continue
			}

			if pid != curr_pid && IsPidRunningPROCESSES(pid) &&
					(time.Now().UnixNano() - ts) < ((MAX_WAIT_NEXT_TIMESTAMP_S + 1) * 1e9) {
				return true
			}
		}
	}

	return false
}

func ModSignalStopMODULES(mod_num int) bool {
	return nil == getUserDataDirMODULES(mod_num).Add2(false, "STOP").Create(true)
}

/*
IsModSupportedMODULES checks if a module is supported on the current machine.

-----------------------------------------------------------

– Params:
  - mod_num – the number of the module

– Returns:
  - true if the module is supported, false otherwise
 */
func IsModSupportedMODULES(mod_num int) bool {
	switch mod_num {
		case NUM_MOD_ModManager:
			return true
		case NUM_MOD_SMARTChecker:
			return isMOD2Supported()
		case NUM_MOD_RssFeedNotifier:
			return isMOD4Supported()
		case NUM_MOD_EmailSender:
			return isMOD5Supported()
		case NUM_MOD_OnlineInfoChk:
			return isMOD6Supported()
	}

	return false
}
